#pragma once

#include "isocity/Export.hpp"     // RgbaImage + PNG RGBA IO
#include "isocity/GfxTileset.hpp" // GfxAtlasEntry

#include <string>
#include <vector>

namespace isocity {

// Runtime/tooling loader for the sprite atlas + metadata produced by proc_isocity_tileset.
//
// This stays dependency-free by reusing:
//  - the project's minimal JSON parser (Json.hpp)
//  - the project's minimal PNG RGBA IO (ReadPngRGBA)
//
// Entries are stored sorted by name for deterministic lookup.
struct GfxTilesetAtlas {
  // Base color atlas (RGBA).
  RgbaImage atlas;

  // Optional emissive atlas (RGBA), same size/layout as atlas.
  RgbaImage emissiveAtlas;

  // Optional derived atlases (RGBA), same size/layout as atlas.
  // These are generated by proc_isocity_tileset when requested.
  RgbaImage normalAtlas;
  RgbaImage shadowAtlas;

  // Sprite rectangles + pivots (sorted by name).
  std::vector<GfxAtlasEntry> entries;

  // Convenience: inferred tile size from terrain sprites (0 if unknown).
  int tileW = 0;
  int tileH = 0;

  // Convenience: discovered variant counts from metadata (0 if not present).
  int terrainVariants = 0;      // terrain_*_vN
  int roadVariants = 0;         // road_*_vN
  int bridgeVariants = 0;       // bridge_*_vN
  int transitionVariantsWS = 0; // terrain_shore_ws_*_vN
  int transitionVariantsSG = 0; // terrain_shore_sg_*_vN

  // Optional prop/vehicle variants (0 if not present).
  int propTreeDeciduousVariants = 0; // prop_tree_deciduous_vN
  int propTreeConiferVariants = 0;   // prop_tree_conifer_vN
  int propStreetlightVariants = 0;   // prop_streetlight_vN
  int propCarVariants = 0;           // prop_car_vN
  int propTruckVariants = 0;         // prop_truck_vN

  // Building variants [kind][level-1]. kind: 0=res,1=com,2=ind.
  int buildingVariants[3][3] = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};

  bool hasEmissive = false;
  bool hasNormals = false;
  bool hasShadows = false;

  bool valid() const { return atlas.width > 0 && atlas.height > 0 && !atlas.rgba.empty() && !entries.empty(); }
  bool emissiveValid() const
  {
    return hasEmissive && emissiveAtlas.width == atlas.width && emissiveAtlas.height == atlas.height && !emissiveAtlas.rgba.empty();
  }

  bool normalValid() const
  {
    return hasNormals && normalAtlas.width == atlas.width && normalAtlas.height == atlas.height && !normalAtlas.rgba.empty();
  }

  bool shadowValid() const
  {
    return hasShadows && shadowAtlas.width == atlas.width && shadowAtlas.height == atlas.height && !shadowAtlas.rgba.empty();
  }
};

// Load a tileset atlas and its JSON metadata. Returns true on success.
bool LoadGfxTilesetAtlas(const std::string& atlasPngPath, const std::string& metaJsonPath, GfxTilesetAtlas& out, std::string& outError);

// Load an emissive atlas (optional). The metadata JSON must already have been loaded.
bool LoadGfxTilesetAtlasEmissive(const std::string& emissivePngPath, GfxTilesetAtlas& io, std::string& outError);

// Load a normal-map atlas (optional). The base atlas + metadata must already have been loaded.
bool LoadGfxTilesetAtlasNormals(const std::string& normalPngPath, GfxTilesetAtlas& io, std::string& outError);

// Load a shadow-mask atlas (optional). The base atlas + metadata must already have been loaded.
bool LoadGfxTilesetAtlasShadows(const std::string& shadowPngPath, GfxTilesetAtlas& io, std::string& outError);

// Find a sprite entry by name. Returns nullptr if not found.
const GfxAtlasEntry* FindGfxAtlasEntry(const GfxTilesetAtlas& ts, const std::string& name);

} // namespace isocity
